<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ESP Arcade - Tetris</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/retro.css') }}">
</head>
<body>
    <nav class="arcade-nav">
        {% if current_user.is_authenticated %}
            <a href="{{ url_for('hub') }}">GAMES</a>
            <a href="{{ url_for('settings') }}">CONFIG</a>
            <a href="{{ url_for('logout') }}">LOGOUT</a>
        {% else %}
            <a href="{{ url_for('login') }}">INSERT COIN</a>
        {% endif %}
    </nav>

    <div class="container center-box">
        {% with messages = get_flashed_messages() %}
            {% if messages %}
                <div class="flash">{{ messages[0] }}</div><br>
            {% endif %}
        {% endwith %}

        <h2 class="text-pink">TETRIS</h2>
        <div style="margin-bottom: 10px;">
            HI-SCORE: <span id="highScore" class="text-pink">{{ high_score }}</span> 
            &nbsp;|&nbsp; 
            LINES: <span id="score">0</span>
        </div>

        <div style="position: relative; width: fit-content; margin: auto;">
            <canvas id="gameCanvas" width="240" height="400" class="game-container border-pink"></canvas>

            <!-- Locked/Paused Overlay -->
            <div id="overlay" class="locked-overlay" style="display: none;">
                <h3 class="text-red">PAUSED</h3>
                <p>CONTROLLER OFFLINE</p>
                <div class="blink-dot"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script>
        (function() {
            const socket = io();
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const overlay = document.getElementById('overlay');

            const ROW = 20;
            const COL = 12;
            const SQ = 20;
            const VACANT = "black";

            // Game State
            let board = [];
            let score = 0;
            let gameRunning = true; 
            let dropStart = Date.now();
            let currentPiece; 
            let isFirstPiece = true; 

            // --- SHAPES ---
            const SHAPE_I = [
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ];

            const SHAPE_J = [
                [1, 0, 0],
                [1, 1, 1],
                [0, 0, 0]
            ];

            const SHAPE_L = [
                [0, 0, 1],
                [1, 1, 1],
                [0, 0, 0]
            ];

            const SHAPE_O = [
                [0, 0, 0, 0],
                [0, 1, 1, 0],
                [0, 1, 1, 0],
                [0, 0, 0, 0]
            ];

            const SHAPE_S = [
                [0, 1, 1],
                [1, 1, 0],
                [0, 0, 0]
            ];

            const SHAPE_T = [
                [0, 1, 0],
                [1, 1, 1],
                [0, 0, 0]
            ];

            const SHAPE_Z = [
                [1, 1, 0],
                [0, 1, 1],
                [0, 0, 0]
            ];

            const PIECES = [
                [SHAPE_Z, "red"],
                [SHAPE_S, "green"],
                [SHAPE_T, "purple"],
                [SHAPE_O, "yellow"],
                [SHAPE_L, "orange"],
                [SHAPE_I, "cyan"],
                [SHAPE_J, "blue"]
            ];

            // --- SOCKET / CONTROLLER ---
            socket.on('controller_status', (data) => {
                if (data.action === "connected") {
                    overlay.style.display = "none";
                    gameRunning = true;
                    dropStart = Date.now(); 
                    requestAnimationFrame(gameLoop);
                } else if (data.action === "disconnected") {
                    overlay.style.display = "flex";
                    gameRunning = false;
                }
            });

            socket.on('game_input', (data) => {
                if (!gameRunning || overlay.style.display === "flex") return;
                
                if (data.dx === -1) currentPiece.moveLeft();
                if (data.dx === 1) currentPiece.moveRight();
                if (data.dy === 1) currentPiece.moveDown(); 
                if (data.dy === -1) currentPiece.rotate(); 
            });

            // --- DRAWING FUNCTIONS ---
            function drawSquare(x, y, color) {
                ctx.fillStyle = color;
                ctx.fillRect(x*SQ, y*SQ, SQ, SQ);
                ctx.strokeStyle = "#333";
                ctx.strokeRect(x*SQ, y*SQ, SQ, SQ);
            }

            function drawBoard() {
                for (let r = 0; r < ROW; r++) {
                    for (let c = 0; c < COL; c++) {
                        drawSquare(c, r, board[r][c]);
                    }
                }
            }

            // --- PIECE OBJECT ---
            function Piece(tetromino, color) {
                this.tetromino = tetromino;
                this.color = color;
                
                // FIXED: Directly assign the matrix, don't try to access index [0]
                this.activeTetromino = this.tetromino; 
                
                this.x = 4; 
                this.y = -2; // Start above board 
            }

            Piece.prototype.fill = function(color) {
                for (let r = 0; r < this.activeTetromino.length; r++) {
                    for (let c = 0; c < this.activeTetromino.length; c++) {
                        if (this.activeTetromino[r][c]) {
                            drawSquare(this.x + c, this.y + r, color);
                        }
                    }
                }
            }

            Piece.prototype.draw = function() {
                this.fill(this.color);
            }

            Piece.prototype.moveDown = function() {
                if (!this.collision(0, 1, this.activeTetromino)) {
                    this.y++;
                } else {
                    this.lock();
                    currentPiece = randomPiece(); // Next piece logic
                }
            }

            Piece.prototype.moveRight = function() {
                if (!this.collision(1, 0, this.activeTetromino)) {
                    this.x++;
                }
            }

            Piece.prototype.moveLeft = function() {
                if (!this.collision(-1, 0, this.activeTetromino)) {
                    this.x--;
                }
            }

            Piece.prototype.rotate = function() {
                let nextPattern = [];
                let N = this.activeTetromino.length;
                
                for(let i=0; i<N; i++) nextPattern.push(new Array(N).fill(0));
                for(let y=0; y<N; y++){
                    for(let x=0; x<N; x++){
                        nextPattern[x][N-1-y] = this.activeTetromino[y][x];
                    }
                }

                if (this.collision(0, 0, nextPattern)) {
                    if (this.x > COL/2) { 
                        if (!this.collision(-1, 0, nextPattern)) {
                            this.x -= 1;
                        } else {
                            return; 
                        }
                    } else { 
                        if (!this.collision(1, 0, nextPattern)) {
                            this.x += 1;
                        } else {
                            return; 
                        }
                    }
                }
                this.activeTetromino = nextPattern;
            }

            Piece.prototype.collision = function(x, y, piece) {
                for (let r = 0; r < piece.length; r++) {
                    for (let c = 0; c < piece.length; c++) {
                        if (!piece[r][c]) {
                            continue;
                        }
                        let newX = this.x + c + x;
                        let newY = this.y + r + y;
                        
                        if (newX < 0 || newX >= COL || newY >= ROW) {
                            return true;
                        }
                        if (newY < 0) {
                            continue;
                        }
                        if (board[newY][newX] != VACANT) {
                            return true;
                        }
                    }
                }
                return false;
            }

            Piece.prototype.lock = function() {
                for (let r = 0; r < this.activeTetromino.length; r++) {
                    for (let c = 0; c < this.activeTetromino.length; c++) {
                        if (!this.activeTetromino[r][c]) {
                            continue;
                        }
                        if (this.y + r < 0) {
                            gameRunning = false;
                            submitScore();
                            return;
                        }
                        board[this.y + r][this.x + c] = this.color;
                    }
                }
                
                for (let r = 0; r < ROW; r++) {
                    let isRowFull = true;
                    for (let c = 0; c < COL; c++) {
                        isRowFull = isRowFull && (board[r][c] != VACANT);
                    }
                    if (isRowFull) {
                        for (let y = r; y > 1; y--) {
                            for (let c = 0; c < COL; c++) {
                                board[y][c] = board[y - 1][c];
                            }
                        }
                        for (let c = 0; c < COL; c++) {
                            board[0][c] = VACANT;
                        }
                        score += 10;
                        document.getElementById('score').innerText = score;
                    }
                }
            }

            // --- HELPER FUNCTIONS ---
            function randomPiece() {
                if (isFirstPiece) {
                    isFirstPiece = false;
                    // Index 3 is SHAPE_O (Yellow)
                    return new Piece(PIECES[3][0], PIECES[3][1]);
                }
                let r = Math.floor(Math.random() * PIECES.length);
                return new Piece(PIECES[r][0], PIECES[r][1]);
            }

            function initBoard() {
                for (let r = 0; r < ROW; r++) {
                    board[r] = [];
                    for (let c = 0; c < COL; c++) {
                        board[r][c] = VACANT;
                    }
                }
            }

            function submitScore() {
                alert("Game Over! Score: " + score);
                fetch('/api/submit_score', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({game: 'tetris', score: score})
                }).then(r => r.json()).then(d => {
                    if (d.new_record) document.getElementById('highScore').innerText = score;
                    resetGame();
                });
            }

            function resetGame() {
                initBoard();
                score = 0;
                document.getElementById('score').innerText = score;
                isFirstPiece = true; 
                currentPiece = randomPiece();
                gameRunning = true;
                dropStart = Date.now();
                requestAnimationFrame(gameLoop);
            }

            // --- MAIN GAME LOOP ---
            function gameLoop() {
                if (!gameRunning) return;

                let now = Date.now();
                let delta = now - dropStart;

                if (delta > 1000) {
                    currentPiece.moveDown();
                    dropStart = Date.now();
                }

                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                drawBoard();
                currentPiece.draw();

                requestAnimationFrame(gameLoop);
            }

            resetGame();

        })();
    </script>
</body>
</html>